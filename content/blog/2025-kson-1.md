+++
title = "An escape route from YAML hell"
date = "2025-09-17"
+++

We have all been there. Your software keeps growing and you feel the need to make it customizable. It is too soon for a full-blown UI with all the bells and whistles, so your pragmatic instinct suggests a text-based configuration file. Yes, that's exactly it!

You rejoice knowing the software's configuration will be trivial to version control. Your pragmatic instinct is satisfied as well; the door remains open to creating a proper UI later, since it would be merely a graphical view of your configuration's structured data. The future is bright!

Now, which language should you pick for your glorious configuration file? It needs to be user-friendly, so people can inspect it and modify it with ease. JSON springs immediately to your mind, but the abundance of brackets and the lack of comments give you pause. TOML maybe? You are afraid it might be too minimal for your needs. Rolling your own language? Too impractical.

### YAML

A forbidden spark lights inside your head. Any attempts to put it out are futile. It grows and grows until it finally stands ablaze before you, tempting you with its warmth: why not YAML? Yes, YAML, which is so pleasant to the eye and widely used across the industry. How could you say no to that?

Shivers run down your spine as you remember [the yaml document from hell](https://ruudvanasseldonk.com/2023/01/11/the-yaml-document-from-hell). So often have you been warned about YAML's deceptive simplicity! It's a traitorous mask, your elders said, behind which a dark being lurks. Don't ever come near, it will swallow your soul when you least expect it.

And yet... could YAML indeed be the pragmatic solution in this particular case? We are talking about a small configuration file here. What could possibly go wrong? Surely the gods of software wouldn't punish you for this offense? How could they ask you to swim against the current, when even renowned projects such as Kubernetes use YAML pervasively?

Trembling, you stretch your hand towards the forbidden fruit, reap it and take a good bite. The flavor of instant productivity fills your mouth with delight and you feel confirmed in your choice. Why did you even doubt? After a few code changes your software is configurable through a YAML file. The dopamine surge overwhelms you, and you put the icing on the cake by adding an example configuration to the project's readme.

But alas, superficial satisfaction cannot last. As the years go by, the sweet flavor in your mouth turns bitter. Your software has grown. The once simple configuration file now spans more than a hundred lines. Yes, the file is pleasant to _look_ at, but _modifying_ it is nothing short of miserable. Why did you disregard ancient wisdom? In silence, you mourn your lost innocence and the fallen state of humanity.

Ah, if you could begin again.

### The crux of the problem

Do you recognize yourself in this story? I have seen it play out a few times and feel like we, as an industry, have somehow come to terms with the miserable situation we are in. Once in a while you may see some brave and noble soul proposing a new configuration language, but so far none has achieved mass adoption. What is going on?

The crux of the problem is, in my eyes, beyond the domain of configuration language choice (i.e., YAML vs. alternatives). We seem to be approaching the very problem of configuration from a flawed starting point, setting way too low expectations for our tools. We are failing to see that configuration files are actually user interfaces, and that they should be treated as such.

Once you start thinking of configuration files as user interfaces, it suddenly makes sense to demand an excellent user experience for working with them. The whole point of a user interface is to make the software accessible, with mechanisms that prevent human error and guide the user down the [pit of success](https://blog.codinghorror.com/falling-into-the-pit-of-success/). We all recognize bad UX when it feels like you are fighting the computer to achieve a specific goal. In an ideal world, the computer would enhance you without getting in the way, like a [bicycle for the mind](https://www.pixelandtimber.com/bcl-journal/2019/7/11/bicycle-for-the-mind).

What would configuring software look like if our tools were rooted in the "configuration is UI" paradigm? Can we realistically dream of an ecosystem in which configuration is a joy to write and maintain?

### Enter KSON

Having come to this point I can't avoid mentioning [KSON](https://kson.org), an [open source](https://github.com/kson-org/kson/) project which had its first beta release this week, after years in the making. From what I've seen, KSON is an excellent real-world example of the "configuration is UI" vision, even though it's still early days.

If you have the time (and interest), I'd encourage you to check out the concise [release blog post](https://kson.org/docs/blog/2025/09/17/introducing-kson/), visit [the website](https://kson.org) and play with [the playground](https://kson.org/playground/). That will give you a *much* better idea of the project than anything I could write here. You know what they say: show, don't tell.

For those who'd rather skip the links above, let me briefly quote some paragraphs from the announcement:

> Anywhere a human is reading or editing YAML/JSON/TOML, KSON may be used as a more effective interface on that data.

That's a bold claim right there! But maybe it's warranted, especially once you consider the sheer amount of work that has gone into the current beta release:

> KSON is a [verified superset of JSON](https://github.com/kson-org/kson/pull/72), has [native JSON Schema support](https://github.com/kson-org/kson/pull/186), transpiles cleanly to [YAML (with comments preserved!)](https://github.com/kson-org/kson/pull/80), and is likely available wherever you want itâ€”current supported platforms: [JS/TS](https://www.npmjs.com/package/@kson_org/kson), [Python](https://pypi.org/project/kson-lang/), [Rust](https://crates.io/crates/kson-rs), [JVM](https://central.sonatype.com/artifact/org.kson/kson-jvm), and [Kotlin Multiplatform](https://central.sonatype.com/artifact/org.kson/kson).
>
> KSON is also widely available in developer tools, with support for [VS Code](https://marketplace.visualstudio.com/items?itemName=kson.kson), [Jetbrains IDEs](https://plugins.jetbrains.com/plugin/28510-kson-language), and anywhere you can plug in an [LSP](https://github.com/kson-org/kson/blob/main/tooling/language-server-protocol/README.md).

See the appendix at the end of this article for an example KSON document. You will notice that the language feels familiar and that it has been designed from the ground up to provide an excellent editing experience.

By the way, I love to see advanced language support in code editors from day one! This is, in my view, a necessary consequence of the "configuration is UI" paradigm. It lets the document come to life under your fingertips, instead of being a dead text file.

What a breath of fresh air! I'm hoping the vision of "configuration as UI" will unfold over time, revealing new ways to further improve user experience[^1], getting closer and closer to configuration that is a joy to write and maintain.

### Join the movement

In case it's not clear yet, I'm enthusiastic about KSON! If you visited the open source repository, you might even have seen me among the contributors to the project[^2]. Besides the technical merits of KSON, I'm impressed by the driving force behind it: a small community of engineers has decided to bite the bullet and craft open software configuration tools that put humans first. It truly is "a love letter to the humans maintaining computer configurations", as it says in the repository's tagline.

I'd even go as far as saying KSON wants to be more than a new language or a collection of tools. To me, KSON is also an attempt to bootstrap a developer movement. It aims at setting a new standard in which configuration files are considered UI, and people get used to having a top-tier editing experience. There is no reason to keep putting up with the status quo.

If this vision resonates with you, please join us in our effort! Merely trying out KSON is already a good start. And, if you end up liking it, go use it wherever it makes sense! This is particularly helpful during the public beta, so we can iron out any potential flaws in the language design or its implementation. Also, you are more than welcome in our [Zulip](https://kson-org.zulipchat.com) instance. I'm looking forward to meeting you there!

#### Appendix: a KSON example

While this blog post is about the principles behind the project, and not about the KSON language, here's a tiny example of a `.kson` file derived from a dbt model:

```yaml
version: 2
models:
  - name: my_transformation
    description: 'This model transforms raw data'
    columns:
      - name: id
        description: 'A unique identifier'
      - name: name
        description: 'The name of the item'
        .
    database: your_database
    schema: your_schema
    materialized: table
    sql: %sql
      SELECT
        id,
        name
      FROM source_data%%
```

As you can see, it has the readability of YAML, which is a great feature in my book! Importantly, however, KSON carefully avoids classic YAML footguns. One example of that is indentation handling: the code snippet above is indented in a way that makes the structure of the document evident. But, contrary to YAML, having "wrong" indentation does not break your configuration. If you were to remove or randomize the leading spaces for every line, the following would happen:

1. The document would parse to the same object as before.
2. KSON would warn you that the document's formatting is confusing, because the indentation doesn't match the structure of the document (fortunately, the autoformatter can trivially fix the warning for you on save).

An additional feature that is not immediately apparent here is that the embedded SQL is actually "alive". A properly configured editor will see more than a multiline string there! It will know that it's SQL, it will provide syntax highlighting for it, validation, and all other goodies you are used to when dealing with code.

See the [official website](https://kson.org) for more information and a space to play with KSON right from your browser.

[^1]: Next to library support for more programming languages, which is boring but necessary work, there is a (growing) list of potential features to enhance KSON with in the [issue tracker](TODO).
[^2]: While I'm one of the contributors to KSON, most of the credit goes to [Daniel](https://github.com/dmarcotte), who has been behind the project since 2021 and has spent countless hours making it awesome. Next in line comes [Bart](https://github.com/holodorum), who started helping out in 2024 and has been a key player in getting KSON to its beta release.
